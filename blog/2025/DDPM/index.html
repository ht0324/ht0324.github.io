<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>DDPM – Review | Hun Tae Kim</title> <meta name="author" content="Hun Tae Kim"> <meta name="description" content="My thoughts on the Denoising Diffusion Probabilistic Models paper"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css2?family=Source+Sans+3:ital,wght@0,300;0,400;0,500;0,600;0,700;1,400;1,600&amp;family=Source+Serif+4:ital,opsz,wght@0,8..60,400;0,8..60,500;0,8..60,600;0,8..60,700;1,8..60,400;1,8..60,600&amp;display=swap"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Material+Icons"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?19f3075a2d19613090fe9e16b564e1fe" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%F0%9F%9A%80&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://ht0324.github.io/blog/2025/DDPM/"> </head> <body class="fixed-top-nav " style="overflow-x: hidden; max-width: 100vw;"> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title" href="/">Hun Tae Kim</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/Links/">Links</a> </li> <li class="nav-item "> <a class="nav-link" href="/CV/">CV</a> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" style="overflow-x: hidden;"> <div class="post"> <header class="post-header"> <h1 class="post-title">DDPM – Review</h1> <div class="post-meta-wrapper"> <span> <i class="fas fa-calendar fa-sm"></i> March 10, 2025 </span> </div> <div class="post-tag-wrapper"> <a href="/blog/tag/ai" class="tag-pill"> <i class="fas fa-hashtag fa-sm"></i> AI</a> <a href="/blog/category/paper" class="tag-pill"> <i class="fas fa-folder fa-sm"></i> Paper</a> </div> </header> <article class="post-content"> <div id="markdown-content"> <p>This time, I’m looking at the paper <a href="https://arxiv.org/abs/2006.11239" rel="external nofollow noopener" target="_blank">“Denoising Diffusion Probabilistic Models”</a>, often referred to as DDPM. This paper presented impressive image generation results using diffusion models, a class of models inspired by non-equilibrium thermodynamics.</p> <p>The core idea is quite interesting: train a model to reverse a gradual noising process. You start with structured data (like an image), progressively add Gaussian noise over many steps until only noise remains, and then train a neural network to reverse this process, starting from noise and gradually denoising it step-by-step to generate a sample.</p> <hr> <h3 id="key-concepts">Key Concepts</h3> <p><strong>Forward Process (Diffusion)</strong><br> This is a fixed (non-learned) process defined by a variance schedule. At each step <code class="language-plaintext highlighter-rouge">t</code>, a small amount of Gaussian noise is added to the data from step <code class="language-plaintext highlighter-rouge">t-1</code>. This gradually corrupts the input data towards a simple noise distribution (e.g., standard Gaussian) after <code class="language-plaintext highlighter-rouge">T</code> steps. A neat property is that you can sample the noisy state <code class="language-plaintext highlighter-rouge">x_t</code> directly from the original data <code class="language-plaintext highlighter-rouge">x_0</code> using a closed-form equation involving the cumulative product of variances (ᾱ_t), avoiding iteration.</p> <p><strong>Reverse Process (Denoising)</strong><br> This is the learned part. It’s also a Markov chain, aiming to reverse the forward process. Starting from pure noise <code class="language-plaintext highlighter-rouge">x_T</code>, it iteratively predicts the distribution of the previous (less noisy) state <code class="language-plaintext highlighter-rouge">x_{t-1}</code> given the current state <code class="language-plaintext highlighter-rouge">x_t</code>. Each step <code class="language-plaintext highlighter-rouge">p_θ(x_{t-1}|x_t)</code> is parameterized as a Gaussian whose mean and variance are predicted by a neural network (often a U-Net) that takes <code class="language-plaintext highlighter-rouge">x_t</code> and the timestep <code class="language-plaintext highlighter-rouge">t</code> as input.</p> <p><strong>Training Objective (ELBO &amp; Simplified Loss)</strong><br> Training optimizes a variational lower bound (ELBO) on the data likelihood, similar to VAEs. This ELBO can be expressed as a sum of KL divergence terms comparing the reverse process steps to tractable posteriors of the forward process. However, the authors found that a simplified objective function works very well. Instead of directly predicting the mean of the previous state <code class="language-plaintext highlighter-rouge">x_{t-1}</code>, the network is trained to predict the <em>noise</em> (ε) that was added during the corresponding forward step. The simplified objective (L_simple) becomes a simple mean squared error between the true noise and the predicted noise (ε_θ). This formulation connects diffusion models to denoising score matching and Langevin dynamics.</p> <hr> <h3 id="key-takeaways-what-i-learned">Key Takeaways (What I Learned)</h3> <p><strong>Predicting Noise, Not the Image (Directly)</strong><br> Initially, the idea of training the network to predict noise (ε_θ) was confusing. Why predict random noise? The insight was that it’s not predicting <em>any</em> noise, but the <em>specific</em> noise vector ε that was sampled and added to a <em>specific</em> <code class="language-plaintext highlighter-rouge">x_0</code> at a <em>specific</em> step <code class="language-plaintext highlighter-rouge">t</code> to produce the input <code class="language-plaintext highlighter-rouge">x_t</code>. By doing this across all timesteps and data points, the network learns the relationship between noise patterns and image structures at different noise levels. It learns the “directionality” needed to remove noise correctly.</p> <p><strong>The Simplified Loss Works Surprisingly Well</strong><br> The paper proposes using a simplified objective (L_simple, Eq. 14) which ignores the complex weighting terms present in the full variational bound (derived from Eq. 12). It’s just a mean squared error on the predicted noise. It felt like this was offloading a lot of the theoretical complexity onto the neural network’s learning capacity, but empirically, it leads to the best sample quality. This practical simplification was a significant takeaway.</p> <p><strong>Discrete Data Needs Care at the End</strong><br> Since the diffusion process operates in continuous space (adding Gaussian noise), but image data is typically discrete (e.g., pixel values 0-255), the final step of the reverse process needs special handling. Equation 13 describes how to get discrete log-likelihoods by integrating the final continuous Gaussian output <code class="language-plaintext highlighter-rouge">N(x_0; μ_θ(x_1, 1), σ_1^2 * I)</code> over the appropriate “bins” corresponding to each discrete pixel value. It’s a necessary step to bridge the continuous model and discrete data.</p> <p><strong>Good Samples, Okay Likelihood</strong><br> The paper notes that while DDPMs achieve excellent sample quality (state-of-the-art FID scores at the time), their log-likelihoods (NLL) weren’t as competitive as some other likelihood-based models like flows or autoregressive models. This suggests an interesting trade-off – the inductive bias of the diffusion process seems particularly good for perceptual quality, even if it doesn’t assign the absolute highest probability density to the training data compared to models explicitly optimizing NLL.</p> <p><strong>Math is Dense, Intuition is Key</strong><br> The paper is mathematically quite dense, especially the derivations connecting the ELBO to the noise prediction objective. Following every step was challenging. However, the core intuition – reversing a gradual noising process by learning to predict the noise added at each step – is relatively clear and provides a good handle on how these models work.</p> <p><strong>Connection to Score Matching &amp; Langevin Dynamics</strong><br> The noise prediction parameterization <code class="language-plaintext highlighter-rouge">ε_θ</code> explicitly connects DDPM training to denoising score matching across multiple noise scales, and the sampling process (Algorithm 2) resembles annealed Langevin dynamics. This provides a nice link to other areas of generative modeling and physics-inspired methods.</p> <hr> <h3 id="summary--final-thoughts">Summary &amp; Final Thoughts</h3> <p>DDPMs offer a powerful approach to generative modeling by learning to reverse a fixed diffusion process. The key idea of predicting the added noise at each step, trained with a simplified objective, leads to state-of-the-art sample quality. While the underlying theory is mathematically involved, the core mechanism is intuitive. The trade-off between excellent sample quality and good-but-not-best likelihood scores highlights the unique properties of this model class. It’s a dense paper, but the core ideas are definitely worth understanding.</p> </div> </article><div id="giscus_thread" style="max-width: 800px; margin: 0 auto;"> <script>let giscusTheme=localStorage.getItem("theme"),giscusAttributes={src:"https://giscus.app/client.js","data-repo":"ht0324/ht0324.github.io","data-repo-id":"","data-category":"Comments","data-category-id":"","data-mapping":"title","data-strict":"1","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":giscusTheme,"data-lang":"en",crossorigin:"anonymous",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([t,e])=>giscusScript.setAttribute(t,e)),document.getElementById("giscus_thread").appendChild(giscusScript);</script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2025 Hun Tae Kim. All Rights Reserved. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?7b30caa5023af4af8408a472dc4e1ebb"></script> <script defer src="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script> <script defer src="/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script> <script defer src="/assets/js/copy_code.js?c9d9dd48933de3831b3ee5ec9c209cac" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-7ZMBS6JQKV"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-7ZMBS6JQKV");</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>